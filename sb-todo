#!/bin/bash

# Config
todo_file="${XDG_DATA_HOME:-$HOME/.local/share}/todo/todo.md"
leader="todo: "
total_width=40
width=$((total_width - ${#leader}))
state_file="/tmp/dwm_todo_scroll.pos"
log_file="/tmp/dwm_todo_scroll_debug.log"

# Handle dwmblocks mouse input
case $BLOCK_BUTTON in
1) pos=0 ;;                                         # M1 -> reset scroll position
2) kitty --class floatkitty $EDITOR "$todo_file" ;; # M3 -> open in editor
3) notify-send "$(cat "$todo_file")

 *** M3 to open in editor ***" ;; # M2 -> noti with contents
7) echo "" >$state_file ;;
esac

# Exit early if no TODO file
if [[ ! -f "$todo_file" ]]; then
	echo "No TODO file" && exit 0
fi

# Function to extract items between two headings
extract_items() {
	awk -v start="$1" -v stop="$2" '
        BEGIN { in_section=0 }
        $0 ~ start { in_section=1; next }
        $0 ~ stop && in_section { exit }
        in_section && !/^[[:space:]]*#/ && !/^[[:space:]]*$/ { print $0 }
    ' "$todo_file"
}

# Get items under "## now" and above "## backlog"
items=$(extract_items "^## now" "^## backlog")

# If empty, fallback to backlog section
if [[ -z "$items" ]]; then
	items=$(awk '
        BEGIN { in_backlog=0 }
        /^## backlog/ { in_backlog=1; next }
        /^## / && in_backlog { exit }
        in_backlog && !/^[[:space:]]*#/ && !/^[[:space:]]*$/ { print $0 }
    ' "$todo_file")
fi

# If still nothing, exit
if [[ -z "$items" ]]; then
	exit 0
fi

# Concatenate all items into a single string, separated by " ... "
text=$(echo "$items" | awk 'ORS=" ... "' | sed 's/ ... $//')

# Trim leading/trailing whitespace
text=$(echo "$text" | xargs)

# If nothing left, exit with no output
if [[ -z "$text" ]]; then
	exit 0
fi

length=${#text}

# If it fits, print the full string with trailing space and exit
if ((length <= width)); then
	echo "[ $leader$text ]"
	exit 0
fi

# Prepare scrolling text (looped)
scroll_text="~ $text   ~ $text"

# Load or init scroll position
if [[ -f "$state_file" ]]; then
	pos=$(<"$state_file")
else
	pos=0
fi

# Advance scroll position on normal update
if [[ -z "$BLOCK_BUTTON" ]]; then
	((pos++))
fi

# Wrap scroll position
((pos < 0)) && pos=$((length - 1))
((pos >= length + 4)) && pos=0

# Save scroll position
echo "$pos" >"$state_file" || echo "Failed to write state" >>"$log_file"

# Output the scrolling portion
echo -n "[ $leader${scroll_text:pos:width} ]"
